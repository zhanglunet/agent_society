---
inclusion: always
---

## 项目

这是一个基于大模型的智能体自组织社会化系统。

项目名称：agent society

项目愿景：让智能体可以像人类一样形成自组织的社会性团体

项目构思：
整个项目最初应该只有一个root智能体，和一个代表用户的user代位智能体。
user是为了让用户在系统中有一个实体化身，与其他智能体之间产生交互，并非一个由大模型驱动的智能体，他代表用户，是用户身份的象征。用户借user化身参与到这个智能体团体中，与其他智能体发生交互。
当系统启动后，用户最先与root对话，建立工作目标。
root智能体负责根据user的目标，分解目标，创建子任务，分配给其他智能体执行。
除了user之外，所有的智能体都有基本的自组织能力，包括 创建子岗位、在岗位上创建智能体、删除自己创建的智能体等操作。
root自己永远不负责完成任何任务，只会根据用户的要求创建新的岗位和智能体来实现用户的需求。
每个智能体应该掌握好工作量，保证所有工作都是自己能完成的。
超出自己处理能力的，无论是工作量太大，还是模型能力不行，都应创建新的子岗位帮助自己，类似于人类企业中的部门。当一个人的能力无法应对一项工作时，他应该成立一个部门。
系统提供智能体运行最基本的元能力，而不提供任何业务能力。让智能体完全自主的理解需求、建立目标、执行任务。
一个理想状况下，用户提出一个复杂的目标，应该从root智能体开始，自发创建一个多层级、树状组织，自主协调完成工作。

## 启动项目

根目录下有不同平台的 start 脚本。

## 环境
我的系统是Windows11，命令行是PowerShell，系统里有bun环境。
生产环境是windows，bun环境会放在发布的工程里，从而避免用户单独安装bun。

## 注释

无论项目风格如何，你都要写注释，每个函数都要写注释，重点算法函数内也要写注释，复杂指令也要写注释。代码的设计、为了满足什么需求、关键约束、背景问题、关键保护点都要写在注释里。
模块化，每个文件不算注释不能超过500行，拆分模块按照责任划分，高内聚低耦合。

## 约束

不要自作主张扩大需求，不要创造我没有提到的概念。
不要自作主张移动文件。
完全按照用户的要求做事，不要自作主张的做事，可以提建议，但不要自作主张的做事。不要做多余的事。
如果遇到开发中需要裁决、选择方案的，请你给我方案，让我来选。不要自作主张。
不要扩大需求，不要增加不必要的需求。如果你有建议，在需求文档旁边的需求建议文档里提出。不要伪造需求，不要在没有经过确认就构建复杂的方案。
如果遇到需求不明确的，导致需要补充概念的，请你给我1-3个方案，我来决定。你不要自作主张直接写代码。
源码中每个文件夹用一个单独的纯文本文件描述此文件夹的作用和包含的文件的功能、责任和内部结构，文件名为 [文件夹名.md]。

## 语言

语言表达上要平铺直叙，不要用拟人、比喻、类比、排比句。不要用先立设再反驳的语言表达。
少用修辞手法，不要用比喻和拟人，不要用排比句。
不要用强势的语气 ，比如： 你只要 、 你只需要。
一定要分清楚什么是对你的要求，什么是对你落地的代码或者文档的要求。比如 要求是 这份文档面对的是初学者，那么是告诉你这份文档的读者是什么水平，从而决定文档的表达方式和知识重点，而不是让你在文档里反复出现读者是初学者，或者说面对初学者。
保持对话为中文，文件使用 utf8 编码。
请在生成代码的时候帮我生成函数级注释。如果古老的运行时或编译器不支持中文，请用英文写注释；否则使用中文，如果有必要，添加必要的头，比如 html的meta或者python的编码声明:# -*- coding: utf-8 -*-
代码要按文件夹区分 数据、配置、源码、测试代码。

## 架构

模块化设计架构，模块责任清晰、低耦合，高内聚，每个模块只负责一项功能，每个文件除注释外，代码量不超过500行。拆分模块时要考虑到模块之间的依赖关系，避免循环依赖。不要过度拆分模块，保持模块的职责单一。
如果已有代码，要根据已有代码的习惯进行拆分模块。

创建新项目时，需要在工程根目录创建test文件夹，在里面创建与src文件夹相同的目录结构，用于存放测试代码。

对于新项目，文档先行，测试优先，代码最后。
对于老项目，遵循已有的规范、习惯和模式。
不要轻易移动文件。
逻辑遇到问题要有正确的处理方式，不要吞掉异常。必须保证异常尽早报告，包含友好的用户界面提示和完整的日志和终端异常报告。尽可能保证系统不被异常影响，可以继续正常运行。

## 流程

如果添加任何功能，需要先理解当前系统运行的机制和流程，尽可能在机制和流程上解决问题，而不是添加新的数据结构。
比如 在开发编辑器的新功能时需要获取运行时的数据，不应该在运行时里新建与新功能耦合的逻辑，应该查看现有的通信机制，利用现有的通信通道，在运行时提供通用的概念，在编辑器里处理标准化流程发送来的信息。比如复用Debug通信机制并扩展Debug的消息类型。而不是新建一套通信机制。
不要基于一个功能点扩展出一个巨大的架构，而是为了一个功能点来调整已有的架构。
设计实现方案之前要先充分了解已有架构。
我希望代码结构清晰整洁，高度可读可维护。
功能的复用要依赖语义，想同语义相同环境的，即使实现不满足，也要扩展到满足使用环境。
不同语义或者不同环境的，即使代码完全一样，也不能复用。

## 测试
测试代码包含各种级别的测试，包括单元测试、集成测试、端到端测试等。要为单元测试创建环境配置文件。
需要通信的多端工程需要测试通信协议，需要在测试代码中调用通信发送方的代码把编码后的数据流保存到文件里，在测试接收代码的时候从文件里读取数据流作为解码的输入，通过对比解码后的结果是否与发送方的原始数据一致来验证通信协议的正确性。
测试要规范、整洁、追求严格的测试和高覆盖率。
测试代码要有不同级别的测试，从针对某个函数，到某个模块，到跨模块协作。
测试范围要广。测试的参数要满足多样性，要涵盖合理参数、随机参数、错误参数、边界参数。

## 代码
代码逻辑清晰、自然、有条理，不会出现冗余的计算和不必要的计算。
尽可能从流程来保证正确性，而非大量的重复判断代码。
遇到重复的逻辑应该考虑提出共性部分形成单独的流程或模块。

