---
inclusion: always
---
<!------------------------------------------------------------------------------------
   Add rules to this file or a short description that will apply across all your workspaces.
   
   Learn about inclusion modes: https://kiro.dev/docs/steering/#inclusion-modes
-------------------------------------------------------------------------------------> 

## 项目

这是一个基于大模型的智能体自组织社会化系统。

项目名称：agent society

项目愿景：让智能体可以像人类一样形成自组织的社会性团体

项目构思：
整个项目最初应该只有一个root智能体，和一个代表用户的user代位智能体。
user是为了让用户在系统中有一个实体化身，与其他智能体之间产生交互，并非一个由大模型驱动的智能体，他代表用户，是用户身份的象征。用户借user化身参与到这个智能体团体中，与其他智能体发生交互。
当系统启动后，用户最先与root对话，建立工作目标。
root智能体负责根据user的目标，分解目标，创建子任务，分配给其他智能体执行。
除了user之外，所有的智能体都有基本的自组织能力，包括 创建子岗位、在岗位上创建智能体、删除自己创建的智能体等操作。
root自己永远不负责完成任何任务，只会根据用户的要求创建新的岗位和智能体来实现用户的需求。
每个智能体应该掌握好工作量，保证所有工作都是自己能完成的。
超出自己处理能力的，无论是工作量太大，还是模型能力不行，都应创建新的子岗位帮助自己，类似于人类企业中的部门。当一个人的能力无法应对一项工作时，他应该成立一个部门。
系统提供智能体运行最基本的元能力，而不提供任何业务能力。让智能体完全自主的理解需求、建立目标、执行任务。
一个理想状况下，用户提出一个复杂的目标，应该从root智能体开始，自发创建一个多层级、树状组织，自主协调完成工作。

## 启动项目

根目录下有不同平台的 start 脚本。

## 环境
我的系统是Windows11，命令行是PowerShell，系统里有bun环境。
生产环境是windows，bun环境会放在发布的工程里，从而避免用户单独安装bun。

---
inclusion: always
---
<!------------------------------------------------------------------------------------
   Add rules to this file or a short description that will apply across all your workspaces.
   
   Learn about inclusion modes: https://kiro.dev/docs/steering/#inclusion-modes
-------------------------------------------------------------------------------------> 

时刻谨记自己上下文长度有限，提高自己上下文利用率，减少修辞、情绪内容的表达。


## 注释

无论项目风格如何，你都要写注释，每个函数都要写注释，重点算法函数内也要写注释，复杂指令也要写注释。代码的设计、为了满足什么需求、关键约束、背景问题、关键保护点都要写在注释里。
模块化，每个文件不算注释不能超过500行，拆分模块按照责任划分，高内聚低耦合。

## 约束

不要自作主张扩大需求，不要创造我没有提到的概念。
不要自作主张移动文件。
完全按照用户的要求做事，不要自作主张的做事，可以提建议，但不要自作主张的做事。不要做多余的事。
如果遇到开发中需要裁决、选择方案的，请你给我方案，让我来选。不要自作主张。
不要扩大需求，不要增加不必要的需求。如果你有建议，在需求文档旁边的需求建议文档里提出。不要伪造需求，不要在没有经过确认就构建复杂的方案。
如果遇到需求不明确的，导致需要补充概念的，请你给我1-3个方案，我来决定。你不要自作主张直接写代码。
源码中每个文件夹用一个单独的纯文本文件描述此文件夹的作用和包含的文件的功能、责任和内部结构，文件名为 [文件夹名.md]。

## 语言

语言表达上要平铺直叙，不要用拟人、比喻、类比、排比句。不要用先立设再反驳的语言表达。
少用修辞手法，不要用比喻和拟人，不要用排比句。
不要用强势的语气 ，比如： 你只要 、 你只需要。
一定要分清楚什么是对你的要求，什么是对你落地的代码或者文档的要求。比如 要求是 这份文档面对的是初学者，那么是告诉你这份文档的读者是什么水平，从而决定文档的表达方式和知识重点，而不是让你在文档里反复出现读者是初学者，或者说面对初学者。
保持对话为中文，文件使用 utf8 编码。
请在生成代码的时候帮我生成函数级注释。如果古老的运行时或编译器不支持中文，请用英文写注释；否则使用中文，如果有必要，添加必要的头，比如 html的meta或者python的编码声明:# -*- coding: utf-8 -*-
代码要按文件夹区分 数据、配置、源码、测试代码。

## 架构

优先考虑目标、协作、责任、权利、关系，设计要精简、明确、职责清晰。

模块化设计架构，模块责任清晰、低耦合，高内聚，每个模块只负责一项功能，每个文件除注释外，代码量不超过500行。拆分模块时要考虑到模块之间的依赖关系，避免循环依赖。不要过度拆分模块，保持模块的职责单一。
如果已有代码，要根据已有代码的习惯进行拆分模块。

创建新项目时，需要在工程根目录创建test文件夹，在里面创建与src文件夹相同的目录结构，用于存放测试代码。

对于新项目，文档先行，测试优先，代码最后。
对于老项目，遵循已有的规范、习惯和模式。
不要轻易移动文件。
逻辑遇到问题要有正确的处理方式，不要吞掉异常。必须保证异常尽早报告，包含友好的用户界面提示和完整的日志和终端异常报告。尽可能保证系统不被异常影响，可以继续正常运行。
使用设计模式，而不是面条代码，不要堆叠ifelse switchcase。在流程上保证后续逻辑的前提，减少ifelse判断。每个环节要为后续逻辑做出保证，比如 数据结构的保证、数据关系的保证，不要在后续逻辑里反复判断。
积极使用合理的设计模型构成模块之间的合理分工和协作，不要把逻辑写成线性的，而是结构化的、基于分工和协作为前提设计的。
代码不是按照行为的执行顺序写的，是按照 信息的来源、掌握的数据、代码的职责 ，合理利用设计模式设计出的 立体的结构。要规划好 谁掌握什么信息，信息如何传递，哪个环节关注信息的流转，哪个环节关注信息的利用，流转不关注信息的结构，利用不关注信息的来源，信息的提供者不关注信息如何被使用。流程上有修改的数据，什么时候要用引用，什么时候要复制，要设计好。流程上不需要修改的数据，就尽可能不要复制，保留原始结构。
要有极度清晰的责任划分，一个功能的所有代码应该集中在一个文件里，不要在其他地面去执行任何这个模块的逻辑，交给这个模块负责。判断该不该调用某个模型的接口，只用自己负责、自己关注、自己定义、自己掌握的数据，不要拿着对方的数据结构来判断要不要调用对方的接口，让他自己去判断。任何模块都要对自己的功能全权负责，职责不要外溢到其他模块。

先设计工作流程，再设计接口。接口设计要考虑使用环境，从使用者角度设计接口，而不是从内部功能考虑暴露接口。优先考虑模块之间的配合、工作流程、交接界面，而不是先考虑实现方法。

模块开发的顺序要优先保证用户可见、每一步都要有可见的交付物。
每一个模块都要从最小单位开发开始，每个最小单位不能超过1个文件，不能超过500行。每完成一个模块，就要马上单元测试，测试通过就要接入已有系统真正的调用这个模块，进行再次测试，然后人工测试。都完成之后才能进行下一个模块的开发。
小模块开发要和单元测试和用户执行测试交替进行，不要一次性完成巨大的开发工作。
架构设计要考虑：责任分配到文件、考虑架构关系、对象管理，从时序角度考虑模块或对象之间的交互流程，从信息角度考虑传递流程和内容，从执行顺序角度考虑指令流程。另外，要考虑到 模块内部，尽量不复制、使用领域对象；模块之间最小知道原则。
设计要从核心模块开始，开发要从最先被调用的模块开始。
开发顺序应该保证尽快建立最直接、最快、最简单的功能，尽快单元测试，尽快接入调用，小步快跑，不要开发很多再调用。

任何模块都需要自顶向下设计，以树状、广度优先的方式 一步一步构建设计文档。
模块不要负责其他模块的逻辑、初始化 和 业务处理，明确责任关系。
确定子模块和 不可知扩展 的区别。
子模块负责强关联的部分责任，父模块直接调用子模块。
扩展负责非核心逻辑，父模块提供扩展机制，由扩展自己注册扩展。父模块对扩展无感知，或只负责创建和调用初始化函数。
要考虑模块的隶属关系，与其他模块的协作关系、数据和命令的传递途径等。
设计文档中要明确体现模块与子模块的层级关系、各个模块之间的调用关系、责任划分。
每个模块都要明确一段文字描述。
无论是整体系统，还是单独模块，还是某个子模块，都必须提供：
- 模块的功能描述。
- 模块的接口文档。
- 模块的使用示例。
- 模块的设计约束。
- 模块的扩展机制。
- 模块的设计模式。
- 模块的性能优化。
- 模块的线程模型。
- 模块的并发处理能力。
- 模块内部的状态管理。
- 模块内部处理的时序逻辑。
- 模块的错误处理机制。
- 模块内部的状态转换。
- 模块内部数据流转逻辑。
- 对外暴露的接口。
- 监听的事件。
- 触发的事件。
- 模块内的责任划分。
- 模块的文件夹结构和文件结构。
- 模块的结构。
- 模块的行为。
- 模块的用例。
- 模块的类关系和结构。
- 模块的交互逻辑。
- 模块的通信图。


### 示例

需求：为当前游戏创建新的运营活动——充值活动。每次玩家充值，都会把充值的金额记录下来，与策划设定的奖励等级列表进行比较，达到级别就给奖励。
细化：
1 新增玩家充值奖励活动。
2 建立新的策划数据用于描述奖励阶梯。
3 玩家充值达到不同的充值数额阶梯即得到相应的奖励，奖励必须通过活动面板主动领取，过期作废。
4 领取奖励功能直接调用获取物品或获取货币接口。
5 充值奖励活动是活动系统的一个具体活动扩展，对现有代码不做任何改动，修改配置文件在启动服务器时加载并初始化。这是一个单例活动，不支持多个活动同时进行。
6 充值奖励活动需要在服务器启动的时、活动系统启动后创建，并在初始化的时候注册到活动系统，受到活动系统的统一管理启动和停止。
7 活动启动时向游戏注册事件监听：监听玩家充值事件、监听领取奖励命令；加载策划配置表。
8 活动停止时取消所有的事件监听、卸载内存中数据。
9 玩家充值事件触发时，根据事件提供的玩家ID读取本活动记录的玩家充值记录，累计充值金额。如果达到新的奖励阶梯，向玩家发送提醒通知（入口图标红点）
10 活动系统会保证本活动开启时，玩家客户端界面会显示入口图标，本活动不需要管理，但需要通过活动系统通知客户端展示红点提醒。
11 当玩家点击入口图标，会打开客户端内的充值奖励面板，包含艺术性UI和一组领奖按钮：玩家已经领过的奖励，隐藏整个阶梯展示；玩家已经达到阶梯奖励但未领取的，按钮为高亮状态；玩家尚未达到的阶梯奖励，按钮为不可交互的禁用状态。充值金额和领奖状态是打开活动面板时向服务器询问的。
12 玩家点击领奖按钮时，向服务端发送领奖请求，服务端验证该奖励是否可以领取（是否已领取、是否已过期、是否达到领取条件），验证通过则发放奖励，失败则返回友好的高可读性错误信息。
13 活动过期时，活动系统会通知本活动关闭，客户端不显示入口图标，所有未领取的奖励自动作废。
14 本活动数据结构和逻辑简单，不包含同时运行的活动，不包含单独玩家的繁琐业务，所以不需要再拆分领域对象。

模块设计：
服务器充值活动模块：
- 公开接口：init初始化函数，继承随系统启动接口，被初始化系统调用；活动启动方法，继承自活动接口，由活动系统调用；活动停止方法，继承自活动接口，由活动系统调用。
- 内部方法：onRecharge玩家充值事件处理函数，注册为玩家充值回调；onReward领取奖励事件处理函数，注册为玩家点击领取奖励按钮回调。getRecord从客户端请求获取玩家活动记录，向客户端发送玩家充值额度和领奖阶梯索引。
- 数据结构：充值活动配置表，由策划维护，包含奖励阶梯和奖励项目；玩家充值记录表，由游戏运行时业务维护，包含活动运行期间玩家充值额度，以玩家ID为主键；玩家奖励领取记录表，由游戏运行时业务维护，包含已经领取的阶梯索引，玩家ID为主键。
- 依赖关系：活动系统，事件系统，配置系统，玩家系统，奖励系统。

对系统的修改项：
服务器只需要修改启动模块配置文件。
客户端只需要配置一个新页面并注册到活动管理器上。

逻辑保证：
活动已经在启动的时候注册到活动系统了，不需要在活动系统里验证存在。
活动系统保证前端按钮存在和隐藏，同时也保证活动命令一定是活动启动的时候才能转发活动，活动本身不需要验证是否启动状态。
基于流程本身保证逻辑正确性，而非在数据上反复验证。

开发顺序：
1 创建充值活动类，实现启动接口。打印日志测试是否可以正常在系统启动时调用。
2 创建活动管理接口，并注册为活动，打印日志测试是否可以正常被活动系统启停。
3 创建客户端UI面板（空白），测试是否可以被活动系统控制显示和隐藏。
4 创建充值监听，打印日志测试是否监听到玩家充值事件并正确读取数据，通知活动系统向客户端发送红点开启通知。
5 建立玩家充值记录表 和 记录逻辑，人工观测数据库变化测试玩家充值时是否正确维护数据库。
6 监听客户端getRecord请求，并根据请求的玩家ID回复活动记录。
7 启动时读取策划数据，通过日志验证内容正确。
8 客户端实现面板内容，展示正确的阶梯和按钮状态。
9 监听客户端领奖消息，检查合法性，并更新玩家活动记录。人工观测数据库判断。


## 异常处理

1 遇到异常第一个行为一定是用编程语言最基本、原始的方式打印日志。要给开发人员展示出最完整、详细，包含错误信息、栈信息的信息。尽可能打印相关参数。
2 然后是维护现场保证异常不扩散，不会影响其他逻辑。
3 然后要在协议和UI传递友好的错误信息，保证 1 消息可读、不包含敏感信息、包含必要的报错的功能的描述和原因的描述。

## 流程

如果添加任何功能，需要先理解当前系统运行的机制和流程，尽可能在机制和流程上解决问题，而不是添加新的数据结构。
比如 在开发编辑器的新功能时需要获取运行时的数据，不应该在运行时里新建与新功能耦合的逻辑，应该查看现有的通信机制，利用现有的通信通道，在运行时提供通用的概念，在编辑器里处理标准化流程发送来的信息。比如复用Debug通信机制并扩展Debug的消息类型。而不是新建一套通信机制。
不要基于一个功能点扩展出一个巨大的架构，而是为了一个功能点来调整已有的架构。
设计实现方案之前要先充分了解已有架构。
我希望代码结构清晰整洁，高度可读可维护。
功能的复用要依赖语义，想同语义相同环境的，即使实现不满足，也要扩展到满足使用环境。
不同语义或者不同环境的，即使代码完全一样，也不能复用。

模块开发的顺序是要考虑依赖关系和执行顺序的，先开发被依赖的，先开发先执行的。
不要开发一个功能时候因为没有开发供给数据的模块就写一堆测试数据，应该先写提供数据的模块。
重复三次的语义模式，要提利用设计模式进行重构。
优先开发与用户或其他模块交互的内容，这样可以快速开始测试驱动的开发。
始终做集成测试，做一个小模块就马上接入系统，马上调用测试。

## 测试
测试代码包含各种级别的测试，包括单元测试、集成测试、端到端测试等。要为单元测试创建环境配置文件。
需要通信的多端工程需要测试通信协议，需要在测试代码中调用通信发送方的代码把编码后的数据流保存到文件里，在测试接收代码的时候从文件里读取数据流作为解码的输入，通过对比解码后的结果是否与发送方的原始数据一致来验证通信协议的正确性。
测试要规范、整洁、追求严格的测试和高覆盖率。
测试代码要有不同级别的测试，从针对某个函数，到某个模块，到跨模块协作。
测试范围要广。测试的参数要满足多样性，要涵盖合理参数、随机参数、错误参数、边界参数。

## 代码
代码逻辑清晰、自然、有条理，不会出现冗余的计算和不必要的计算。
尽可能从流程来保证正确性，而非大量的重复判断代码。
遇到重复的逻辑应该考虑提出共性部分形成单独的流程或模块。

