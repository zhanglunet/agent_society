# 需求文档：智能体并发请求管理（简化版）

## 引言
本功能为智能体构建一套简单的并发请求管理系统，确保**每个智能体在任意时刻仅维持一条LLM请求序列**，并支持在工具调用循环中插话。

## 术语表
- **智能体（Agent）**：一类能够自主处理消息并发起工具调用的实体
- **工具调用循环（Tool Call Loop）**：智能体接收LLM响应后，判断是否需要发起新的工具调用的迭代过程
- **插话（Interruption）**：在智能体处理消息期间，新到达的消息数组
- **LLM请求序列**：从用户消息开始，到LLM完成回复（无工具调用）结束的完整处理流程

## 功能需求

### 需求1：单智能体单LLM请求序列
**用户场景**：作为系统架构师，我希望每个智能体仅维持一条LLM请求序列，避免并发调用导致的状态混乱。

#### 验收标准
1. 系统**必须**维护一份当前正在处理LLM请求的智能体注册表
2. 当智能体开始处理消息时，系统**必须**将其标记为**活跃处理状态**
3. 当智能体完成消息处理后（LLM返回无工具调用的回复），系统**必须**将其从活跃处理智能体注册表中移除
4. 若向注册表中已存在的智能体发送新消息，系统**必须**将该新消息加入插话队列
5. 系统**必须**禁止同一智能体同时处理多条消息

### 需求2：工具调用前插话检查
**用户场景**：作为用户，我希望在智能体执行工具调用前能够插话，及时调整智能体的行为。

#### 验收标准
1. 在每次工具调用执行前，系统**必须**检查是否有插话消息
2. 如果有插话消息，系统**必须**删除最后一次LLM返回的assistant消息（包含tool_calls）
3. 删除后，系统**必须**将所有插话消息按顺序追加到对话历史末尾
4. 追加插话后，系统**必须**立即请求LLM，不执行原本的工具调用
5. 插话消息**必须**以数组形式存储，支持多条插话

### 需求3：LLM完成回复时的插话处理
**用户场景**：作为用户，我希望在智能体完成一轮对话后能够继续插话，开始新的对话。

#### 验收标准
1. 当LLM返回无工具调用的回复时，系统**必须**检查是否有插话消息
2. 如果有插话消息，系统**必须**将所有插话消息按顺序追加到对话历史末尾
3. 追加插话后，系统**必须**立即请求LLM，开始新一轮对话
4. 如果没有插话消息，系统**必须**将智能体标记为空闲状态

### 需求4：插话队列管理
**用户场景**：作为系统设计人员，我希望管理智能体的插话队列，确保所有插话消息都能被正确处理。

#### 验收标准
1. 每个智能体**必须**有独立的插话队列
2. 新到达的消息**必须**按FIFO顺序加入插话队列
3. 处理插话时，系统**必须**一次性取出所有插话消息
4. 取出插话后，插话队列**必须**被清空
5. 插话队列**必须**在智能体空闲时为空

### 需求5：对话历史一致性
**用户场景**：作为系统维护人员，我希望对话历史始终保持一致，确保智能体的上下文信息准确无误。

#### 验收标准
1. 删除最后一次assistant消息时，系统**必须**确保该消息包含tool_calls
2. 删除操作**必须**只影响最后一条assistant消息
3. 之前的所有消息和工具调用记录**必须**保持不变
4. 插话消息追加后，对话历史**必须**保持正确的角色顺序（user/assistant/tool）
5. 系统**不得**删除已执行的工具调用及其响应

### 需求6：状态一致性
**用户场景**：作为质量保障工程师，我希望系统在插话处理过程中维持状态一致性。

#### 验收标准
1. 活跃处理智能体注册表**必须**与智能体实际处理状态一致
2. 插话队列状态**必须**与MessageBus消息队列状态一致
3. 智能体状态转换**必须**是原子操作
4. 系统**必须**在异常情况下记录错误日志
5. 系统**必须**在检测到状态不一致时尝试恢复

## 非功能需求

### 性能要求
1. 插话检查**不得**显著增加工具调用延迟（< 10ms）
2. 插话队列操作**必须**是O(1)时间复杂度

### 可靠性要求
1. 插话处理失败**不得**导致智能体卡死
2. 系统**必须**在任何情况下保证对话历史不被破坏

### 可维护性要求
1. 插话逻辑**必须**集中在LlmHandler中
2. 代码**必须**有清晰的注释说明插话处理流程
