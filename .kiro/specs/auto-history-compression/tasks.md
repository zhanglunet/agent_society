# 自动历史消息压缩功能任务清单

## 1. 核心模块开发

### 1.1 AutoCompressionManager 模块

- [ ] 1.1.1 创建 AutoCompressionManager 类基础结构
  - 创建 `src/platform/services/conversation/auto_compression_manager.js`
  - 实现构造函数，接收 configService、llmClient、logger 参数
  - 实现基础的配置读取逻辑

- [ ] 1.1.2 实现 token 使用情况计算
  - 实现 `_calculateTokenUsage(messages)` 方法
  - 从消息数组中统计 token 使用情况
  - 计算使用率百分比

- [ ] 1.1.3 实现压缩判断逻辑
  - 实现 `_shouldCompress(messages)` 方法
  - 基于配置的阈值判断是否需要压缩
  - 确保消息数量足够进行压缩

- [ ] 1.1.4 实现消息提取逻辑
  - 实现 `_extractMessagesToCompress(messages)` 方法
  - 提取需要压缩的消息（保留系统提示词和最近消息）
  - 返回待压缩的消息数组

- [ ] 1.1.5 实现摘要生成功能
  - 实现 `_generateSummary(messages)` 方法
  - 实现 `_buildSummaryPrompt(messages)` 方法
  - 调用 LLM 生成压缩摘要
  - 处理摘要生成失败的情况

- [ ] 1.1.6 实现压缩执行逻辑
  - 实现 `_performCompression(messages, summary)` 方法
  - 直接修改消息数组，实现压缩效果
  - 保留系统提示词、摘要和最近消息

- [ ] 1.1.7 实现主入口方法
  - 实现 `process(messages)` 方法
  - 整合所有压缩流程
  - 实现错误处理和日志记录

### 1.2 ConversationManager 扩展

- [ ] 1.2.1 添加压缩管理器支持
  - 在构造函数中添加 autoCompressionManager 参数
  - 实现 `setAutoCompressionManager(manager)` 方法
  - 确保对现有代码的修改最少

- [ ] 1.2.2 实现自动压缩调用接口
  - 实现 `processAutoCompression(agentId)` 方法
  - 获取会话消息数组并传递给压缩管理器
  - 处理会话不存在的情况

### 1.3 LlmHandler 集成

- [ ] 1.3.1 在 LLM 调用前添加自动压缩检查
  - 修改 `handleWithLlm()` 方法
  - 在 LLM 调用前调用自动压缩
  - 确保自动压缩失败不影响 LLM 调用

## 2. 配置管理

### 2.1 配置项定义

- [ ] 2.1.1 定义自动压缩配置结构
  - 定义 AutoCompressionConfig 接口
  - 设置默认配置值
  - 确保配置项的合理性

- [ ] 2.1.2 配置文件示例
  - 在 `config/app_template.json` 中添加配置示例
  - 提供配置项说明
  - 确保 summaryModel 为必需配置

### 2.2 配置读取逻辑

- [ ] 2.2.1 实现配置服务集成
  - 在 AutoCompressionManager 中读取配置
  - 支持运行时配置更新
  - 处理配置缺失的情况

## 3. 日志和监控

### 3.1 日志记录

- [ ] 3.1.1 实现压缩过程日志
  - 记录自动压缩触发时的状态
  - 记录压缩前后的消息数量变化
  - 记录摘要生成的结果

- [ ] 3.1.2 实现错误日志
  - 记录摘要生成失败的详细信息
  - 记录压缩异常的错误信息
  - 使用结构化日志格式

### 3.2 性能监控

- [ ] 3.2.1 添加性能指标
  - 记录摘要生成耗时
  - 记录压缩操作耗时
  - 监控压缩成功率

## 4. 测试开发

### 4.1 单元测试

- [ ] 4.1.1 AutoCompressionManager 单元测试
  - 测试配置读取功能
  - 测试 token 使用情况计算
  - 测试压缩判断逻辑
  - 测试消息提取功能
  - 测试摘要生成功能
  - 测试压缩执行逻辑

- [ ] 4.1.2 ConversationManager 扩展测试
  - 测试压缩管理器设置
  - 测试自动压缩调用接口
  - 测试错误处理

- [ ] 4.1.3 LlmHandler 集成测试
  - 测试自动压缩触发条件
  - 测试压缩失败不影响 LLM 调用
  - 测试日志记录

### 4.2 集成测试

- [ ] 4.2.1 完整压缩流程测试
  - 创建测试智能体和会话
  - 模拟达到压缩阈值的场景
  - 验证压缩结果的正确性
  - 验证智能体继续正常工作

- [ ] 4.2.2 配置变更测试
  - 测试不同配置下的压缩行为
  - 测试配置缺失的处理
  - 测试运行时配置更新

- [ ] 4.2.3 错误场景测试
  - 测试摘要生成失败的处理
  - 测试 LLM 调用失败的处理
  - 测试网络异常的处理

### 4.3 性能测试

- [ ] 4.3.1 摘要生成性能测试
  - 测试不同消息数量下的生成时间
  - 验证超时机制的有效性
  - 测试并发压缩的性能

- [ ] 4.3.2 压缩效果测试
  - 验证压缩后的 token 减少效果
  - 测试压缩对智能体性能的影响
  - 验证压缩摘要的质量

## 5. 文档和部署

### 5.1 技术文档

- [ ] 5.1.1 API 文档
  - 编写 AutoCompressionManager API 文档
  - 编写配置项说明文档
  - 编写集成指南

- [ ] 5.1.2 故障排查文档
  - 编写常见问题解答
  - 编写日志分析指南
  - 编写性能调优指南

### 5.2 用户文档

- [ ] 5.2.1 功能说明文档
  - 编写自动压缩功能介绍
  - 编写配置指南
  - 编写最佳实践建议

### 5.3 部署准备

- [ ] 5.3.1 配置模板更新
  - 更新配置文件模板
  - 添加配置验证逻辑
  - 提供迁移指南

## 6. 优化和扩展（可选）

### 6.1 性能优化

- [ ] 6.1.1 摘要缓存机制
  - 实现摘要结果缓存
  - 避免重复生成相同内容的摘要
  - 实现缓存过期机制

- [ ] 6.1.2 批量压缩优化
  - 支持多个智能体并行压缩
  - 实现压缩任务队列
  - 优化资源使用

### 6.2 功能扩展

- [ ] 6.2.1 智能压缩策略
  - 根据消息重要性选择性保留
  - 根据任务类型调整压缩策略
  - 学习用户的压缩偏好

- [ ] 6.2.2 多级压缩支持
  - 支持多次压缩，逐步精简历史
  - 保留多个压缩级别的摘要
  - 根据需要恢复不同级别的历史

## 实施顺序

### 第一阶段：核心功能（必需）
1. AutoCompressionManager 模块开发（1.1）
2. ConversationManager 扩展（1.2）
3. LlmHandler 集成（1.3）
4. 配置管理（2.1-2.2）
5. 基础测试（4.1）

### 第二阶段：完善功能（必需）
1. 日志和监控（3.1-3.2）
2. 集成测试（4.2）
3. 性能测试（4.3）
4. 文档编写（5.1-5.2）

### 第三阶段：部署和优化（可选）
1. 部署准备（5.3）
2. 性能优化（6.1）
3. 功能扩展（6.2）

## 验收标准

### 功能验收
- [ ] 自动压缩在达到阈值时正确触发
- [ ] 摘要生成功能正常工作
- [ ] 压缩后智能体继续正常工作
- [ ] 压缩失败不影响 LLM 调用
- [ ] 配置项正确生效

### 性能验收
- [ ] 摘要生成时间不超过 30 秒
- [ ] 自动压缩不显著延长 LLM 调用时间
- [ ] 压缩后 token 使用率明显降低

### 质量验收
- [ ] 所有单元测试通过
- [ ] 所有集成测试通过
- [ ] 代码覆盖率达到 80% 以上
- [ ] 无内存泄漏和性能问题
- [ ] 日志记录完整且有用

### 文档验收
- [ ] API 文档完整准确
- [ ] 用户文档易于理解
- [ ] 配置说明清晰明确
- [ ] 故障排查指南实用