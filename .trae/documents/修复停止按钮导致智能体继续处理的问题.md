## 根因分析
- 网页“停止按钮”调用的是 `POST /api/agent/:agentId/abort`。当前后端实现的语义更接近“中断一次 LLM 调用”，而不是“停止该智能体”。
- `abortAgentLlmCall` 只做了：递增 epoch + 尝试 abort 网络请求 + 把 computeStatus 设为 idle；不会清空 MessageBus 队列，也不会清掉 TurnEngine 的 activeTurn/turn queue。
- 所以停止后仍可能：继续处理队列里的消息；以及晚到 LLM 回复虽被 epoch 丢弃，但调度器仍会继续跑其它回合，看起来像“又进入循环”。

## 你提出的约束
- root：可以停止。
- user：不可以停止（user 没有停止概念）。

## 修复目标（与按钮语义一致）
- 点击“停止”应当让该智能体进入 **stopped（暂停）** 状态：
  - 取消 in-flight LLM/tool（尽力 abort + epoch 丢弃）；
  - 清空该智能体 MessageBus 队列；
  - 清理 TurnEngine 内该智能体回合（activeTurn + queue）；
  - computeStatus 保持为 `stopped`，调度器不再 ingest/step；
  - 停止后晚到的 LLM/tool 结果不会恢复 processing，也不会继续推进回合。

## 实施步骤
### 1) 将 /abort 的语义升级为“停止智能体”
- 修改 `RuntimeLifecycle.abortAgentLlmCall(agentId)`：
  - 对 `agentId === 'user'` 返回 `{ok:false, reason:'cannot_stop_user'}`；root 允许。
  - 设置 computeStatus：`stopping` → `stopped`。
  - 触发强取消：`cancelManager.abort(agentId, {reason:'user_stop'})` + `llm.abort(agentId)`。
  - 清空该智能体队列：`bus.clearQueue(agentId)`。
  - 清理回合：`turnEngine.clearAgent(agentId)`。
  - 返回值增加 `stopped:true`（保留 `aborted` 字段兼容旧前端）。

### 2) 调度器对 stopped 语义做硬保护
- 修改 `ComputeScheduler`：
  - `_ingestMessagesToTurns` / `_runOneStep` 已跳过 stopped/stopping/terminating，但还要补：
    - 在 LLM/tool 的 `finally` 里若当前 computeStatus 是 `stopped/stopping/terminating`，不再 `markReady`；
    - `_maybeSetIdle` 不得把 `stopped` 误收敛回 `idle`。

### 3) 前端提示（最小改动）
- 修改 `AgentList.abortLlmCall`：
  - 如果返回 `stopped:true`，提示“已停止智能体处理”；
  - 否则沿用原有“已停止 LLM 调用/没有进行中的 LLM 调用”的提示。
- UI 的 stopped 图标逻辑不变，仍由 `computeStatus==='stopped'` 决定。

### 4) 回归测试
- 新增测试覆盖：
  - stop 后 computeStatus 保持 `stopped`，调度器不会继续推进；
  - stop 后即使 LLM promise resolve，也不会触发 turn 继续或状态回到 processing；
  - stop 会清空队列并清理 TurnEngine 回合；
  - stop user 返回 `cannot_stop_user`。

## 预计改动文件
- `src/platform/runtime/runtime_lifecycle.js`
- `src/platform/runtime/compute_scheduler.js`
- `web/js/components/agent-list.js`
- `test/platform/*.test.js`