{"version":3,"file":"prism-cpp-BCnzBpup.js","sources":["../../node_modules/prismjs/components/prism-cpp.js"],"sourcesContent":["(function (Prism) {\n\n\tvar keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n\tvar modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function () { return keyword.source; });\n\n\tPrism.languages.cpp = Prism.languages.extend('c', {\n\t\t'class-name': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source\n\t\t\t\t\t.replace(/<keyword>/g, function () { return keyword.source; })),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t// This is intended to capture the class name of method implementations like:\n\t\t\t//   void foo::bar() const {}\n\t\t\t// However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n\t\t\t// it starts with an uppercase letter. This approximation should give decent results.\n\t\t\t/\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,\n\t\t\t// This will capture the class name before destructors like:\n\t\t\t//   Foo::~Foo() {}\n\t\t\t/\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,\n\t\t\t// This also intends to capture the class name of method implementations but here the class has template\n\t\t\t// parameters, so it can't be a namespace (until C++ adds generic namespaces).\n\t\t\t/\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/\n\t\t],\n\t\t'keyword': keyword,\n\t\t'number': {\n\t\t\tpattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n\t\t\tgreedy: true\n\t\t},\n\t\t'operator': />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n\t\t'boolean': /\\b(?:false|true)\\b/\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'string', {\n\t\t'module': {\n\t\t\t// https://en.cppreference.com/w/cpp/language/modules\n\t\t\tpattern: RegExp(\n\t\t\t\t/(\\b(?:import|module)\\s+)/.source +\n\t\t\t\t'(?:' +\n\t\t\t\t// header-name\n\t\t\t\t/\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source +\n\t\t\t\t'|' +\n\t\t\t\t// module name or partition or both\n\t\t\t\t/<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function () { return modName; }) +\n\t\t\t\t')'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'string': /^[<\"][\\s\\S]+/,\n\t\t\t\t'operator': /:/,\n\t\t\t\t'punctuation': /\\./\n\t\t\t}\n\t\t},\n\t\t'raw-string': {\n\t\t\tpattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n\t\t\talias: 'string',\n\t\t\tgreedy: true\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'keyword', {\n\t\t'generic-function': {\n\t\t\tpattern: /\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,\n\t\t\tinside: {\n\t\t\t\t'function': /^\\w+/,\n\t\t\t\t'generic': {\n\t\t\t\t\tpattern: /<[\\s\\S]+/,\n\t\t\t\t\talias: 'class-name',\n\t\t\t\t\tinside: Prism.languages.cpp\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'operator', {\n\t\t'double-colon': {\n\t\t\tpattern: /::/,\n\t\t\talias: 'punctuation'\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'class-name', {\n\t\t// the base clause is an optional list of parent classes\n\t\t// https://en.cppreference.com/w/cpp/language/class\n\t\t'base-clause': {\n\t\t\tpattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: Prism.languages.extend('cpp', {})\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('inside', 'double-colon', {\n\t\t// All untokenized words that are not namespaces should be class names\n\t\t'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n\t}, Prism.languages.cpp['base-clause']);\n\n}(Prism));\n"],"names":["Prism"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,GAAC,SAAUA,QAAO;AAEjB,QAAI,UAAU;AACd,QAAI,UAAU,uCAAuC,OAAO,QAAQ,cAAc,WAAY;AAAE,aAAO,QAAQ;AAAA,KAAS;AAExH,IAAAA,OAAM,UAAU,MAAMA,OAAM,UAAU,OAAO,KAAK;AAAA,MACjD,cAAc;AAAA,QACb;AAAA,UACC,SAAS,OAAO,gEAAgE,OAC9E,QAAQ,cAAc,WAAY;AAAE,mBAAO,QAAQ;AAAA,UAAO,CAAE,CAAC;AAAA,UAC/D,YAAY;AAAA;;;;;QAMb;AAAA;AAAA;AAAA,QAGA;AAAA;AAAA;AAAA,QAGA;AAAA;MAED,WAAW;AAAA,MACX,UAAU;AAAA,QACT,SAAS;AAAA,QACT,QAAQ;AAAA;MAET,YAAY;AAAA,MACZ,WAAW;AAAA,IACb,CAAE;AAED,IAAAA,OAAM,UAAU,aAAa,OAAO,UAAU;AAAA,MAC7C,UAAU;AAAA;AAAA,QAET,SAAS;AAAA,UACR,2BAA2B,SAC3B;AAAA,UAEA,mDAAmD,SACnD;AAAA,UAEA,kDAAkD,OAAO,QAAQ,eAAe,WAAY;AAAE,mBAAO;AAAA,WAAU,IAC/G;AAAA;QAED,YAAY;AAAA,QACZ,QAAQ;AAAA,QACR,QAAQ;AAAA,UACP,UAAU;AAAA,UACV,YAAY;AAAA,UACZ,eAAe;AAAA,QACnB;AAAA;MAEE,cAAc;AAAA,QACb,SAAS;AAAA,QACT,OAAO;AAAA,QACP,QAAQ;AAAA,MACX;AAAA,IACA,CAAE;AAED,IAAAA,OAAM,UAAU,aAAa,OAAO,WAAW;AAAA,MAC9C,oBAAoB;AAAA,QACnB,SAAS;AAAA,QACT,QAAQ;AAAA,UACP,YAAY;AAAA,UACZ,WAAW;AAAA,YACV,SAAS;AAAA,YACT,OAAO;AAAA,YACP,QAAQA,OAAM,UAAU;AAAA,UAC7B;AAAA,QACA;AAAA,MACA;AAAA,IACA,CAAE;AAED,IAAAA,OAAM,UAAU,aAAa,OAAO,YAAY;AAAA,MAC/C,gBAAgB;AAAA,QACf,SAAS;AAAA,QACT,OAAO;AAAA,MACV;AAAA,IACA,CAAE;AAED,IAAAA,OAAM,UAAU,aAAa,OAAO,cAAc;AAAA;AAAA;AAAA,MAGjD,eAAe;AAAA,QACd,SAAS;AAAA,QACT,YAAY;AAAA,QACZ,QAAQ;AAAA,QACR,QAAQA,OAAM,UAAU,OAAO,OAAO,CAAA,CAAE;AAAA,MAC3C;AAAA,IACA,CAAE;AAED,IAAAA,OAAM,UAAU,aAAa,UAAU,gBAAgB;AAAA;AAAA,MAEtD,cAAc;AAAA,OACZA,OAAM,UAAU,IAAI,aAAa,CAAC;AAAA,EAEtC,GAAE,KAAK;;;;;;;;;","x_google_ignoreList":[0]}