{"version":3,"file":"prism-js-templates-O7GwjU9p.js","sources":["../../node_modules/prismjs/components/prism-js-templates.js"],"sourcesContent":["(function (Prism) {\n\n\tvar templateString = Prism.languages.javascript['template-string'];\n\n\t// see the pattern in prism-javascript.js\n\tvar templateLiteralPattern = templateString.pattern.source;\n\tvar interpolationObject = templateString.inside['interpolation'];\n\tvar interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\n\tvar interpolationPattern = interpolationObject.pattern.source;\n\n\n\t/**\n\t * Creates a new pattern to match a template string with a special tag.\n\t *\n\t * This will return `undefined` if there is no grammar with the given language id.\n\t *\n\t * @param {string} language The language id of the embedded language. E.g. `markdown`.\n\t * @param {string} tag The regex pattern to match the tag.\n\t * @returns {object | undefined}\n\t * @example\n\t * createTemplate('css', /\\bcss/.source);\n\t */\n\tfunction createTemplate(language, tag) {\n\t\tif (!Prism.languages[language]) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn {\n\t\t\tpattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'template-punctuation': {\n\t\t\t\t\tpattern: /^`|`$/,\n\t\t\t\t\talias: 'string'\n\t\t\t\t},\n\t\t\t\t'embedded-code': {\n\t\t\t\t\tpattern: /[\\s\\S]+/,\n\t\t\t\t\talias: language\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\n\tPrism.languages.javascript['template-string'] = [\n\t\t// styled-jsx:\n\t\t//   css`a { color: #25F; }`\n\t\t// styled-components:\n\t\t//   styled.h1`color: red;`\n\t\tcreateTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),\n\n\t\t// html`<p></p>`\n\t\t// div.innerHTML = `<p></p>`\n\t\tcreateTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),\n\n\t\t// svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n\t\tcreateTemplate('svg', /\\bsvg/.source),\n\n\t\t// md`# h1`, markdown`## h2`\n\t\tcreateTemplate('markdown', /\\b(?:markdown|md)/.source),\n\n\t\t// gql`...`, graphql`...`, graphql.experimental`...`\n\t\tcreateTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),\n\n\t\t// sql`...`\n\t\tcreateTemplate('sql', /\\bsql/.source),\n\n\t\t// vanilla template string\n\t\ttemplateString\n\t].filter(Boolean);\n\n\n\t/**\n\t * Returns a specific placeholder literal for the given language.\n\t *\n\t * @param {number} counter\n\t * @param {string} language\n\t * @returns {string}\n\t */\n\tfunction getPlaceholder(counter, language) {\n\t\treturn '___' + language.toUpperCase() + '_' + counter + '___';\n\t}\n\n\t/**\n\t * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n\t *\n\t * @param {string} code\n\t * @param {any} grammar\n\t * @param {string} language\n\t * @returns {(string|Token)[]}\n\t */\n\tfunction tokenizeWithHooks(code, grammar, language) {\n\t\tvar env = {\n\t\t\tcode: code,\n\t\t\tgrammar: grammar,\n\t\t\tlanguage: language\n\t\t};\n\t\tPrism.hooks.run('before-tokenize', env);\n\t\tenv.tokens = Prism.tokenize(env.code, env.grammar);\n\t\tPrism.hooks.run('after-tokenize', env);\n\t\treturn env.tokens;\n\t}\n\n\t/**\n\t * Returns the token of the given JavaScript interpolation expression.\n\t *\n\t * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n\t * @returns {Token}\n\t */\n\tfunction tokenizeInterpolationExpression(expression) {\n\t\tvar tempGrammar = {};\n\t\ttempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\n\n\t\t/** @type {Array} */\n\t\tvar tokens = Prism.tokenize(expression, tempGrammar);\n\t\tif (tokens.length === 3) {\n\t\t\t/**\n\t\t\t * The token array will look like this\n\t\t\t * [\n\t\t\t *     [\"interpolation-punctuation\", \"${\"]\n\t\t\t *     \"...\" // JavaScript expression of the interpolation\n\t\t\t *     [\"interpolation-punctuation\", \"}\"]\n\t\t\t * ]\n\t\t\t */\n\n\t\t\tvar args = [1, 1];\n\t\t\targs.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\n\n\t\t\ttokens.splice.apply(tokens, args);\n\t\t}\n\n\t\treturn new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\n\t}\n\n\t/**\n\t * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n\t *\n\t * This function has 3 phases:\n\t *\n\t * 1. Replace all JavaScript interpolation expression with a placeholder.\n\t *    The placeholder will have the syntax of a identify of the target language.\n\t * 2. Tokenize the code with placeholders.\n\t * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n\t *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n\t *    tokenized as two tokens by the grammar of the embedded language.\n\t *\n\t * @param {string} code\n\t * @param {object} grammar\n\t * @param {string} language\n\t * @returns {Token}\n\t */\n\tfunction tokenizeEmbedded(code, grammar, language) {\n\t\t// 1. First filter out all interpolations\n\n\t\t// because they might be escaped, we need a lookbehind, so we use Prism\n\t\t/** @type {(Token|string)[]} */\n\t\tvar _tokens = Prism.tokenize(code, {\n\t\t\t'interpolation': {\n\t\t\t\tpattern: RegExp(interpolationPattern),\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t});\n\n\t\t// replace all interpolations with a placeholder which is not in the code already\n\t\tvar placeholderCounter = 0;\n\t\t/** @type {Object<string, string>} */\n\t\tvar placeholderMap = {};\n\t\tvar embeddedCode = _tokens.map(function (token) {\n\t\t\tif (typeof token === 'string') {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\tvar interpolationExpression = token.content;\n\n\t\t\t\tvar placeholder;\n\t\t\t\twhile (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) { /* noop */ }\n\t\t\t\tplaceholderMap[placeholder] = interpolationExpression;\n\t\t\t\treturn placeholder;\n\t\t\t}\n\t\t}).join('');\n\n\n\t\t// 2. Tokenize the embedded code\n\n\t\tvar embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);\n\n\n\t\t// 3. Re-insert the interpolation\n\n\t\tvar placeholders = Object.keys(placeholderMap);\n\t\tplaceholderCounter = 0;\n\n\t\t/**\n\t\t *\n\t\t * @param {(Token|string)[]} tokens\n\t\t * @returns {void}\n\t\t */\n\t\tfunction walkTokens(tokens) {\n\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\tif (placeholderCounter >= placeholders.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (typeof token === 'string' || typeof token.content === 'string') {\n\t\t\t\t\tvar placeholder = placeholders[placeholderCounter];\n\t\t\t\t\tvar s = typeof token === 'string' ? token : /** @type {string} */ (token.content);\n\n\t\t\t\t\tvar index = s.indexOf(placeholder);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\t++placeholderCounter;\n\n\t\t\t\t\t\tvar before = s.substring(0, index);\n\t\t\t\t\t\tvar middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);\n\n\t\t\t\t\t\tvar replacement = [];\n\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\treplacement.push(before);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treplacement.push(middle);\n\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\tvar afterTokens = [after];\n\t\t\t\t\t\t\twalkTokens(afterTokens);\n\t\t\t\t\t\t\treplacement.push.apply(replacement, afterTokens);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));\n\t\t\t\t\t\t\ti += replacement.length - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttoken.content = replacement;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar content = token.content;\n\t\t\t\t\tif (Array.isArray(content)) {\n\t\t\t\t\t\twalkTokens(content);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twalkTokens([content]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twalkTokens(embeddedTokens);\n\n\t\treturn new Prism.Token(language, embeddedTokens, 'language-' + language, code);\n\t}\n\n\t/**\n\t * The languages for which JS templating will handle tagged template literals.\n\t *\n\t * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n\t */\n\tvar supportedLanguages = {\n\t\t'javascript': true,\n\t\t'js': true,\n\t\t'typescript': true,\n\t\t'ts': true,\n\t\t'jsx': true,\n\t\t'tsx': true,\n\t};\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\tif (!(env.language in supportedLanguages)) {\n\t\t\treturn;\n\t\t}\n\n\t\t/**\n\t\t * Finds and tokenizes all template strings with an embedded languages.\n\t\t *\n\t\t * @param {(Token | string)[]} tokens\n\t\t * @returns {void}\n\t\t */\n\t\tfunction findTemplateStrings(tokens) {\n\t\t\tfor (var i = 0, l = tokens.length; i < l; i++) {\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar content = token.content;\n\t\t\t\tif (!Array.isArray(content)) {\n\t\t\t\t\tif (typeof content !== 'string') {\n\t\t\t\t\t\tfindTemplateStrings([content]);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (token.type === 'template-string') {\n\t\t\t\t\t/**\n\t\t\t\t\t * A JavaScript template-string token will look like this:\n\t\t\t\t\t *\n\t\t\t\t\t * [\"template-string\", [\n\t\t\t\t\t *     [\"template-punctuation\", \"`\"],\n\t\t\t\t\t *     (\n\t\t\t\t\t *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n\t\t\t\t\t *         or\n\t\t\t\t\t *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n\t\t\t\t\t *                                  It also has an alias which is the language of the embedded code.\n\t\t\t\t\t *     ),\n\t\t\t\t\t *     [\"template-punctuation\", \"`\"]\n\t\t\t\t\t * ]]\n\t\t\t\t\t */\n\n\t\t\t\t\tvar embedded = content[1];\n\t\t\t\t\tif (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\n\t\t\t\t\t\t// get string content\n\t\t\t\t\t\tvar code = stringContent(embedded);\n\n\t\t\t\t\t\tvar alias = embedded.alias;\n\t\t\t\t\t\tvar language = Array.isArray(alias) ? alias[0] : alias;\n\n\t\t\t\t\t\tvar grammar = Prism.languages[language];\n\t\t\t\t\t\tif (!grammar) {\n\t\t\t\t\t\t\t// the embedded language isn't registered.\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontent[1] = tokenizeEmbedded(code, grammar, language);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfindTemplateStrings(content);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfindTemplateStrings(env.tokens);\n\t});\n\n\n\t/**\n\t * Returns the string content of a token or token stream.\n\t *\n\t * @param {string | Token | (string | Token)[]} value\n\t * @returns {string}\n\t */\n\tfunction stringContent(value) {\n\t\tif (typeof value === 'string') {\n\t\t\treturn value;\n\t\t} else if (Array.isArray(value)) {\n\t\t\treturn value.map(stringContent).join('');\n\t\t} else {\n\t\t\treturn stringContent(value.content);\n\t\t}\n\t}\n\n}(Prism));\n"],"names":["Prism"],"mappings":"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","x_google_ignoreList":[0]}