!(function(e) {
  function t(e2, s2) {
    return s2 <= 0 ? "[]" : e2.replace(/<SELF>/g, (function() {
      return t(e2, s2 - 1);
    }));
  }
  var s = /'[{}:=,](?:[^']|'')*'(?!')/, n = { pattern: /''/, greedy: true, alias: "operator" }, r = { pattern: s, greedy: true, inside: { escape: n } }, a = t("\\{(?:[^{}']|'(?![{},'])|''|<STR>|<SELF>)*\\}".replace(/<STR>/g, (function() {
    return s.source;
  })), 8), i = { pattern: RegExp(a), inside: { message: { pattern: /^(\{)[\s\S]+(?=\}$)/, lookbehind: true, inside: null }, "message-delimiter": { pattern: /./, alias: "punctuation" } } };
  e.languages["icu-message-format"] = { argument: { pattern: RegExp(a), greedy: true, inside: { content: { pattern: /^(\{)[\s\S]+(?=\}$)/, lookbehind: true, inside: { "argument-name": { pattern: /^(\s*)[^{}:=,\s]+/, lookbehind: true }, "choice-style": { pattern: /^(\s*,\s*choice\s*,\s*)\S(?:[\s\S]*\S)?/, lookbehind: true, inside: { punctuation: /\|/, range: { pattern: /^(\s*)[+-]?(?:\d+(?:\.\d*)?|\u221e)\s*[<#\u2264]/, lookbehind: true, inside: { operator: /[<#\u2264]/, number: /\S+/ } }, rest: null } }, "plural-style": { pattern: /^(\s*,\s*(?:plural|selectordinal)\s*,\s*)\S(?:[\s\S]*\S)?/, lookbehind: true, inside: { offset: /^offset:\s*\d+/, "nested-message": i, selector: { pattern: /=\d+|[^{}:=,\s]+/, inside: { keyword: /^(?:few|many|one|other|two|zero)$/ } } } }, "select-style": { pattern: /^(\s*,\s*select\s*,\s*)\S(?:[\s\S]*\S)?/, lookbehind: true, inside: { "nested-message": i, selector: { pattern: /[^{}:=,\s]+/, inside: { keyword: /^other$/ } } } }, keyword: /\b(?:choice|plural|select|selectordinal)\b/, "arg-type": { pattern: /\b(?:date|duration|number|ordinal|spellout|time)\b/, alias: "keyword" }, "arg-skeleton": { pattern: /(,\s*)::[^{}:=,\s]+/, lookbehind: true }, "arg-style": { pattern: /(,\s*)(?:currency|full|integer|long|medium|percent|short)(?=\s*$)/, lookbehind: true }, "arg-style-text": { pattern: RegExp("(^\\s*,\\s*(?=\\S))" + t("(?:[^{}']|'[^']*'|\\{(?:<SELF>)?\\})+", 8) + "$"), lookbehind: true, alias: "string" }, punctuation: /,/ } }, "argument-delimiter": { pattern: /./, alias: "operator" } } }, escape: n, string: r }, i.inside.message.inside = e.languages["icu-message-format"], e.languages["icu-message-format"].argument.inside.content.inside["choice-style"].inside.rest = e.languages["icu-message-format"];
})(Prism);
//# sourceMappingURL=prism-icu-message-format.min-_l84pbfp.js.map
