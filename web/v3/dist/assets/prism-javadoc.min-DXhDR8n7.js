!(function(a) {
  var e = /(^(?:[\t ]*(?:\*\s*)*))[^*\s].*$/m, n = "(?:\\b[a-zA-Z]\\w+\\s*\\.\\s*)*\\b[A-Z]\\w*(?:\\s*<mem>)?|<mem>".replace(/<mem>/g, (function() {
    return "#\\s*\\w+(?:\\s*\\([^()]*\\))?";
  }));
  a.languages.javadoc = a.languages.extend("javadoclike", {}), a.languages.insertBefore("javadoc", "keyword", { reference: { pattern: RegExp("(@(?:exception|link|linkplain|see|throws|value)\\s+(?:\\*\\s*)?)(?:" + n + ")"), lookbehind: true, inside: { function: { pattern: /(#\s*)\w+(?=\s*\()/, lookbehind: true }, field: { pattern: /(#\s*)\w+/, lookbehind: true }, namespace: { pattern: /\b(?:[a-z]\w*\s*\.\s*)+/, inside: { punctuation: /\./ } }, "class-name": /\b[A-Z]\w*/, keyword: a.languages.java.keyword, punctuation: /[#()[\],.]/ } }, "class-name": { pattern: /(@param\s+)<[A-Z]\w*>/, lookbehind: true, inside: { punctuation: /[.<>]/ } }, "code-section": [{ pattern: /(\{@code\s+(?!\s))(?:[^\s{}]|\s+(?![\s}])|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\})+(?=\s*\})/, lookbehind: true, inside: { code: { pattern: e, lookbehind: true, inside: a.languages.java, alias: "language-java" } } }, { pattern: /(<(code|pre|tt)>(?!<code>)\s*)\S(?:\S|\s+\S)*?(?=\s*<\/\2>)/, lookbehind: true, inside: { line: { pattern: e, lookbehind: true, inside: { tag: a.languages.markup.tag, entity: a.languages.markup.entity, code: { pattern: /.+/, inside: a.languages.java, alias: "language-java" } } } } }], tag: a.languages.markup.tag, entity: a.languages.markup.entity }), a.languages.javadoclike.addSupport("java", a.languages.javadoc);
})(Prism);
//# sourceMappingURL=prism-javadoc.min-DXhDR8n7.js.map
